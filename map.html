<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Map - Indus Routes</title>
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link href="fonts/indus-icons.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <style>
        /* Ensure navigation bar displays correctly on map page */
        header.simple_menu {
            z-index: 10000 !important;
            position: fixed !important;
        }
        
        /* Dark background fallback for banner when image is missing */
        .inside_title.image_bck {
            background-color: #292929;
        }
        
        .map-wrapper {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 280px);
            min-height: 600px;
            padding: 0;
            gap: 0;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        
        .map-wrapper .main-content {
            height: 100%;
            display: flex;
            gap: 0;
            flex: 1;
            min-height: 0;
        }
        
        .map-wrapper .map-container {
            flex: 1;
            width: 100%;
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.3s;
        }

        .legend:hover {
            transform: scale(1.02);
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 12px;
            color: #1F2937;
            font-size: 14px;
            border-bottom: 2px solid #E5E7EB;
            padding-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .legend-line {
            width: 35px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-line.dashed {
            background: repeating-linear-gradient(90deg,
                    currentColor,
                    currentColor 6px,
                    transparent 6px,
                    transparent 12px);
        }

        .legend-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }

        .transport-icon-marker {
            background: transparent !important;
            border: none !important;
            transition: transform 0.3s;
        }

        .transport-icon-marker:hover {
            transform: scale(1.2);
        }

        .day-label-marker {
            background: transparent !important;
            border: none !important;
            transition: transform 0.3s;
        }

        .day-label-marker:hover {
            transform: scale(1.15);
        }

        .city-label {
            font-size: 13px;
            font-weight: 600;
            color: #1F2937;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8), -1px -1px 2px rgba(255, 255, 255, 0.8), 1px -1px 2px rgba(255, 255, 255, 0.8), -1px 1px 2px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            white-space: nowrap;
            background: transparent;
        }

        .leaflet-popup-content-wrapper {
            border-radius: 12px !important;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2) !important;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .route-animation {
            animation: pulse 2s ease-in-out infinite;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.9);
            color: #1F2937;
            border: 2px solid #E5E7EB;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .route-tooltip {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(102, 126, 234, 0.3) !important;
            border-radius: 8px !important;
            font-weight: 600 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
        }

        .transport-tooltip {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(102, 126, 234, 0.3) !important;
            border-radius: 8px !important;
            font-weight: 600 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
        }

        .city-popup .leaflet-popup-content-wrapper {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(20px) !important;
        }

        @media (max-width: 1024px) {
            .map-wrapper {
                height: calc(100vh - 300px);
                min-height: 500px;
            }
        }

        /* Map Zoom Notice */
        .map-zoom-notice {
            background: rgba(41, 41, 41, 0.95);
            color: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
        }

        .map-zoom-notice strong {
            color: #fff;
            font-weight: 600;
        }

        .map-zoom-notice i {
            margin-right: 8px;
            color: #667eea;
        }

    </style>
</head>

<body class="passp_white">
<div class="page" id="page">
  <div class="head_bck" data-color="#292929"  data-opacity="0.5"></div>
  
  <!-- Start  Header Section -->
  <div id="nav-placeholder"></div>

  <div class="inside_title image_bck bordered_wht_border white_txt" data-image="img/What-We-Do-banner.jpg" style="min-height: 100px;">
    <!-- Over -->
    <div class="over" data-opacity="0.2" data-color="#000"></div>
    <div class="container">
      <div class="row">
        <div class="col-md-6"><h1>Route Map</h1></div>
        <div class="col-md-6 text-right"><div class="breadcrumbs"><a href="index.html">Home</a> Route Map</div></div>
      </div> 
    </div>
  </div>

  <div class="content">
    <div class="container-fluid">
      <div class="row">
        <div class="bordered_block col-md-12 grey_border">
          <div class="container">
            <div class="map-zoom-notice">
              <i class="fa fa-info-circle"></i>
              <strong>Please zoom in to see more detail</strong> - Use the zoom controls on the map or scroll to explore different areas in greater detail.
            </div>
            <div class="map-wrapper">
              <div class="main-content">
                <div class="map-container">
                  <div id="map"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div> 
    </div>
  </div>

  <div id="footer-placeholder"></div>
  
</div>

    <script>
        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function() {
        // Initialize map centered on India
        const map = L.map('map', {
            zoomControl: true,
            scrollWheelZoom: true,
            doubleClickZoom: true,
            boxZoom: true,
            keyboard: true,
            dragging: true
        }).setView([23.5, 80.0], 5);

        // Base map layer - Clean overview map for showing full route
        const baseMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '© OpenStreetMap contributors © CARTO',
            maxZoom: 19,
            subdomains: 'abcd'
        }).addTo(map);

        // Detailed map layer - Shows more detail when zoomed in
        const detailedMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        });

        // Terrain map layer - Shows terrain features
        const terrainMap = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.{ext}', {
            attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            subdomains: 'abcd',
            minZoom: 0,
            maxZoom: 18,
            ext: 'png'
        });

        // Layer control for switching between map types
        const baseMaps = {
            "Overview Map": baseMap,
            "Detailed Streets": detailedMap,
            "Terrain View": terrainMap
        };

        L.control.layers(baseMaps).addTo(map);

        // City coordinates - mark major cities (flight destinations) vs minor (road destinations)
        const cities = {
            delhi: { lat: 28.6139, lng: 77.2090, name: 'Delhi', isMajor: true },
            nashik: { lat: 19.9975, lng: 73.7898, name: 'Nashik', isMajor: true },
            trimbakeshwar: { lat: 19.9333, lng: 73.5333, name: 'Trimbakeshwar', isMajor: false },
            shirdi: { lat: 19.7645, lng: 74.4777, name: 'Shirdi', isMajor: false },
            guwahati: { lat: 26.1445, lng: 91.7362, name: 'Guwahati', isMajor: true },
            vrindavan: { lat: 27.5806, lng: 77.6979, name: 'Vrindavan/Mathura', isMajor: false }
        };

        // Standard colors: one for flights, one for roads
        const FLIGHT_COLOR = '#3B82F6'; // Blue for flights
        const ROAD_COLOR = '#10B981';   // Green for roads

        // Route data
        const routes = [
            {
                day: 1,
                date: 'Sat, Mar 28, 2026',
                path: ['delhi'],
                transport: 'plane',
                color: FLIGHT_COLOR,
                locations: ['Sai Baba Temple', 'Our Lady of Vailankanni Shrine', 'Khan Market', 'Patte Shah Dargah'],
                overnight: 'Delhi',
                from: 'Airport',
                to: 'Delhi'
            },
            {
                day: 2,
                date: 'Sun, Mar 29, 2026',
                path: ['delhi', 'nashik', 'trimbakeshwar'],
                segments: [
                    { from: 'delhi', to: 'nashik', transport: 'plane' },
                    { from: 'nashik', to: 'trimbakeshwar', transport: 'bus' }
                ],
                transport: 'mixed', // mixed transport for this day
                color: FLIGHT_COLOR, // Use flight color for mixed routes
                locations: ['Flight 7:30am', 'Kala Ram Mandir', 'Trimbakeshwar Temple'],
                overnight: 'Trimbakeshwar',
                from: 'Delhi',
                to: 'Trimbakeshwar'
            },
            {
                day: 3,
                date: 'Mon, Mar 30, 2026',
                path: ['trimbakeshwar', 'shirdi'],
                transport: 'bus',
                color: ROAD_COLOR,
                locations: ['Trimbakeshwar Temple 5:30am', 'Sai Baba Temple'],
                overnight: 'Shirdi',
                from: 'Trimbakeshwar',
                to: 'Shirdi'
            },
            {
                day: 4,
                date: 'Tue, Mar 31, 2026',
                path: ['shirdi', 'delhi'],
                transport: 'plane',
                color: FLIGHT_COLOR,
                locations: ['Sai Temple 4:30am', 'Flight to Delhi'],
                overnight: 'Delhi',
                from: 'Shirdi',
                to: 'Delhi'
            },
            {
                day: 5,
                date: 'Wed, Apr 1, 2026',
                path: ['delhi', 'guwahati'],
                transport: 'plane',
                color: FLIGHT_COLOR,
                locations: ['Flight 10:20am', 'Maa Kamakhya Devi Temple 3:30pm'],
                overnight: 'Guwahati',
                from: 'Delhi',
                to: 'Guwahati'
            },
            {
                day: 6,
                date: 'Thu, Apr 2, 2026',
                path: ['guwahati', 'delhi'],
                transport: 'plane',
                color: FLIGHT_COLOR,
                locations: ['Maa Kamakhya Devi Temple 5:00am', 'Flight 1:15pm'],
                overnight: 'Delhi',
                from: 'Guwahati',
                to: 'Delhi'
            },
            {
                day: 7,
                date: 'Fri, Apr 3, 2026',
                path: ['delhi', 'vrindavan', 'delhi'],
                transport: 'bus',
                color: ROAD_COLOR,
                locations: ['Neem Karoli Baba Samadhi', 'Devraha Baba Samadhi', 'Sripad Baba Ashram', 'Krishna Janambhoomi'],
                overnight: 'Delhi',
                from: 'Delhi',
                to: 'Vrindavan/Mathura'
            },
            {
                day: 8,
                date: 'Sat, Apr 4, 2026',
                path: ['delhi'],
                transport: 'bus',
                color: ROAD_COLOR,
                locations: ['Meet Master', 'Departure'],
                overnight: 'Flight',
                from: 'Delhi',
                to: 'Airport'
            }
        ];

        let routeLayers = {};
        let cityMarkers = {};
        let selectedDay = null;

        // Function to update visibility based on zoom level
        function updateVisibilityBasedOnZoom(zoom) {
            const isZoomedOut = zoom <= 6;

            // Update city markers visibility
            Object.entries(cityMarkers).forEach(([key, cityData]) => {
                const city = cities[key];
                const offset = cityData.offset || { lat: 0.1, lng: 0.1 };

                // Determine color: blue for airport/flight cities, green for road cities
                const cityColor = city.isMajor ? FLIGHT_COLOR : ROAD_COLOR;

                if (isZoomedOut) {
                    // When zoomed out: show only major cities (flight destinations)
                    if (city.isMajor) {
                        cityData.marker.setStyle({
                            radius: 12,
                            fillColor: cityColor,
                            color: '#ffffff',
                            weight: 4,
                            opacity: 1,
                            fillOpacity: 0.95
                        });
                        // Use slightly larger offset when zoomed out to spread labels
                        const zoomOutOffset = {
                            lat: offset.lat,
                            lng: offset.lng * 1.5
                        };
                        cityData.label.setLatLng([city.lat + zoomOutOffset.lat, city.lng + zoomOutOffset.lng]);
                        cityData.label.setOpacity(1);
                    } else {
                        // Hide minor cities when zoomed out
                        cityData.marker.setStyle({ opacity: 0, fillOpacity: 0 });
                        cityData.label.setOpacity(0);
                    }
                } else {
                    // When zoomed in: show all cities with normal offset
                    cityData.marker.setStyle({
                        radius: 10,
                        fillColor: cityColor,
                        color: '#ffffff',
                        weight: 3,
                        opacity: 1,
                        fillOpacity: 0.95
                    });
                    // Use normal offset when zoomed in
                    cityData.label.setLatLng([city.lat + offset.lat, city.lng + offset.lng]);
                    cityData.label.setOpacity(1);
                }
            });

            // Update route visibility
            Object.entries(routeLayers).forEach(([day, layers]) => {
                const route = routes.find(r => r.day === parseInt(day));
                if (!route) return;

                // Check if route has segments
                const hasSegments = route.segments && route.segments.length > 0;

                layers.forEach((layer, layerIdx) => {
                    if (isZoomedOut) {
                        // When zoomed out: show only flight routes
                        let shouldShow = false;

                        if (hasSegments && layer._isSegment) {
                            // For routes with segments, check this specific segment
                            shouldShow = layer._segmentTransport === 'plane';
                        } else if (!hasSegments) {
                            // For single transport routes
                            shouldShow = route.transport === 'plane';
                        }

                        if (shouldShow) {
                            if (layer.setStyle) {
                                layer.setStyle({ opacity: 0.9, fillOpacity: 0.95 });
                            }
                            if (layer.setOpacity) {
                                layer.setOpacity(1);
                            }
                        } else {
                            // Hide road routes when zoomed out
                            if (layer.setStyle) {
                                layer.setStyle({ opacity: 0, fillOpacity: 0 });
                            }
                            if (layer.setOpacity) {
                                layer.setOpacity(0);
                            }
                        }
                    } else {
                        // When zoomed in: show all routes
                        if (layer.setStyle) {
                            layer.setStyle({ opacity: 0.9, fillOpacity: 0.95 });
                        }
                        if (layer.setOpacity) {
                            layer.setOpacity(1);
                        }
                    }
                });
            });
        }

        // Label offsets - all to the right of the city dot (very close)
        const labelOffsets = {
            delhi: { lat: 0, lng: 0.02 },
            nashik: { lat: 0, lng: 0.02 },
            trimbakeshwar: { lat: 0, lng: 0.02 },
            shirdi: { lat: 0, lng: 0.02 },
            guwahati: { lat: 0, lng: 0.02 },
            vrindavan: { lat: 0, lng: 0.02 }
        };

        // Create city markers with labels
        Object.entries(cities).forEach(([key, city]) => {
            // Determine color: blue for airport/flight cities, green for road cities
            const cityColor = city.isMajor ? FLIGHT_COLOR : ROAD_COLOR;

            // City marker
            const marker = L.circleMarker([city.lat, city.lng], {
                radius: 10,
                fillColor: cityColor,
                color: '#ffffff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.95
            }).addTo(map);

            // Simple hover effect
            marker.on('mouseover', function () {
                this.setStyle({
                    radius: 12,
                    weight: 4
                });
            });

            marker.on('mouseout', function () {
                this.setStyle({
                    radius: 10,
                    weight: 3
                });
            });

            // Enhanced popup
            marker.bindPopup(`
                <div style="text-align: center; padding: 5px;">
                    <b style="font-size: 16px; color: ${cityColor};">${city.name}</b>
                </div>
            `, {
                className: 'city-popup'
            });

            // City label - positioned to the right of the city dot
            const offset = labelOffsets[key] || { lat: 0, lng: 0.02 };
            const cityLabel = L.marker([city.lat + offset.lat, city.lng + offset.lng], {
                icon: L.divIcon({
                    html: `<div class="city-label">${city.name}</div>`,
                    className: 'city-label-marker',
                    iconSize: [null, null],
                    iconAnchor: [0, 0]
                }),
                interactive: false,
                zIndexOffset: 500
            }).addTo(map);

            cityMarkers[key] = { marker, label: cityLabel, offset: offset };
        });

        // Helper function to calculate midpoint of a route
        function getMidpoint(coord1, coord2) {
            return [
                (coord1[0] + coord2[0]) / 2,
                (coord1[1] + coord2[1]) / 2
            ];
        }

        // Helper function to calculate bearing (direction) between two coordinates
        function calculateBearing(coord1, coord2) {
            const lat1 = coord1[0] * Math.PI / 180;
            const lat2 = coord2[0] * Math.PI / 180;
            const dLng = (coord2[1] - coord1[1]) * Math.PI / 180;

            const y = Math.sin(dLng) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);

            const bearing = Math.atan2(y, x);
            return (bearing * 180 / Math.PI + 360) % 360;
        }

        // Helper function to create transport icon with realistic SVG
        function createTransportIcon(transport, color, bearing = 0) {
            let svgIcon = '';

            if (transport === 'plane') {
                // Realistic airplane icon pointing right (will be rotated)
                svgIcon = `<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z" fill="${color}" stroke="white" stroke-width="0.5"/>
                </svg>`;
            } else {
                // Bus icon - always straight (not rotated)
                svgIcon = `<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4 16c0 .88.39 1.67 1 2.22V20a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1h8v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1.78c.61-.55 1-1.34 1-2.22V6c0-3.5-3.58-4-8-4s-8 .5-8 4v10zm3.5 1c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm9 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6H6V6h12v5z" fill="${color}" stroke="white" stroke-width="0.5"/>
                </svg>`;
            }

            // Only rotate planes, keep buses straight
            const rotation = transport === 'plane' ? `transform: rotate(${bearing}deg);` : '';

            const iconHtml = `<div style="
                background: white;
                border-radius: 50%;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 8px rgba(0,0,0,0.25);
                border: 2px solid ${color};
                ${rotation}
            ">
                ${svgIcon}
            </div>`;

            return L.divIcon({
                html: iconHtml,
                className: 'transport-icon-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        // Helper function to create arrow marker
        function createArrowMarker(latlng, bearing, color) {
            // Actual arrow shape with shaft and arrowhead pointing north (0 degrees, will be rotated to match bearing)
            const arrowIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Arrow shaft pointing up (north) -->
                <line x1="12" y1="20" x2="12" y2="8" stroke="${color}" stroke-width="3" stroke-linecap="round"/>
                <!-- Arrowhead pointing up (north) -->
                <path d="M12 8 L8 12 M12 8 L16 12" stroke="${color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                <path d="M8 12 L12 8 L16 12 Z" fill="${color}"/>
            </svg>`;

            const iconHtml = `<div style="
                transform: rotate(${bearing}deg);
                display: flex;
                align-items: center;
                justify-content: center;
            ">
                ${arrowIcon}
            </div>`;

            return L.divIcon({
                html: iconHtml,
                className: 'arrow-marker',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        // Function to check if two routes share the same path (reversed)
        function routesSharePath(route1, route2) {
            if (route1.transport !== 'plane' || route2.transport !== 'plane') return false;
            if (route1.path.length !== 2 || route2.path.length !== 2) return false;

            const r1Path = route1.path.join(',');
            const r2Path = route2.path.join(',');
            const r2Reversed = [...route2.path].reverse().join(',');

            return r1Path === r2Reversed;
        }


        // First, identify routes that share the same path (for combining)
        const processedRoutes = new Set();
        const routePairs = [];

        routes.forEach((route1, idx1) => {
            if (processedRoutes.has(idx1)) return;

            routes.forEach((route2, idx2) => {
                if (idx1 >= idx2 || processedRoutes.has(idx2)) return;
                if (routesSharePath(route1, route2)) {
                    routePairs.push({ route1, route2, idx1, idx2 });
                    processedRoutes.add(idx1);
                    processedRoutes.add(idx2);
                }
            });
        });

        // Draw routes with transport symbols
        routes.forEach((route, routeIdx) => {
            // Skip if this route is part of a pair (will be handled separately)
            if (processedRoutes.has(routeIdx)) return;

            const layers = [];

            if (route.path.length > 1) {
                const coordinates = route.path.map(cityKey => {
                    const city = cities[cityKey];
                    return [city.lat, city.lng];
                });

                // Check if route has segments with different transport modes
                if (route.segments && route.segments.length > 0) {
                    // Draw each segment separately with its own transport mode
                    route.segments.forEach((segment, segIdx) => {
                        const fromCity = cities[segment.from];
                        const toCity = cities[segment.to];
                        const segmentCoords = [[fromCity.lat, fromCity.lng], [toCity.lat, toCity.lng]];

                        // Use appropriate color based on transport type
                        const segmentColor = segment.transport === 'plane' ? FLIGHT_COLOR : ROAD_COLOR;

                        // Calculate bearing for direction
                        const bearing = calculateBearing(segmentCoords[0], segmentCoords[1]);

                        // Create solid route line with arrow pattern
                        const routeLine = L.polyline(segmentCoords, {
                            color: segmentColor,
                            weight: 4,
                            opacity: 0.8,
                            smoothFactor: 1,
                            lineCap: 'round',
                            lineJoin: 'round'
                        }).addTo(map);

                        // Store transport type in layer for visibility control
                        routeLine._segmentTransport = segment.transport;
                        routeLine._isSegment = true;

                        layers.push(routeLine);

                        // Add arrow markers along the route
                        const numArrows = 2; // Number of arrows per segment
                        for (let i = 1; i <= numArrows; i++) {
                            const t = i / (numArrows + 1);
                            const arrowLat = segmentCoords[0][0] + (segmentCoords[1][0] - segmentCoords[0][0]) * t;
                            const arrowLng = segmentCoords[0][1] + (segmentCoords[1][1] - segmentCoords[0][1]) * t;
                            const arrowMarker = L.marker([arrowLat, arrowLng], {
                                icon: createArrowMarker([arrowLat, arrowLng], bearing, segmentColor),
                                interactive: false,
                                zIndexOffset: 999
                            }).addTo(map);
                            layers.push(arrowMarker);
                        }

                        // Place one icon at the center of the route with proper bearing
                        const midpoint = getMidpoint(segmentCoords[0], segmentCoords[1]);
                        const transportIcon = createTransportIcon(segment.transport, segmentColor, bearing);
                        const iconMarker = L.marker(midpoint, {
                            icon: transportIcon,
                            interactive: false,
                            zIndexOffset: 1000
                        }).addTo(map);

                        // Store transport type for visibility control
                        iconMarker._segmentTransport = segment.transport;
                        iconMarker._isSegment = true;

                        layers.push(iconMarker);
                    });
                } else {
                    // Single transport mode for entire route
                    // Use appropriate color based on transport type
                    const routeColor = route.transport === 'plane' ? FLIGHT_COLOR : ROAD_COLOR;

                    // Check if this is a round trip (starts and ends at same city, or has return path)
                    const isRoundTrip = route.path[0] === route.path[route.path.length - 1] && route.path.length > 2;

                    // Calculate bearing for direction (from first to last point)
                    const bearing = calculateBearing(coordinates[0], coordinates[coordinates.length - 1]);

                    // Create solid route line
                    const routeLine = L.polyline(coordinates, {
                        color: routeColor,
                        weight: 4,
                        opacity: 0.8,
                        smoothFactor: 1,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }).addTo(map);

                    layers.push(routeLine);

                    // Add arrow markers along the route
                    if (isRoundTrip) {
                        // For round trips, show one arrow going and one arrow coming
                        // One arrow going (on first segment)
                        if (coordinates.length > 1) {
                            const t = 0.5; // Place arrow in middle of first segment
                            const arrowLat = coordinates[0][0] + (coordinates[1][0] - coordinates[0][0]) * t;
                            const arrowLng = coordinates[0][1] + (coordinates[1][1] - coordinates[0][1]) * t;
                            
                            // Calculate bearing for forward direction
                            const forwardBearing = calculateBearing(coordinates[0], coordinates[1]);
                            
                            const arrowMarker = L.marker([arrowLat, arrowLng], {
                                icon: createArrowMarker([arrowLat, arrowLng], forwardBearing, routeColor),
                                interactive: false,
                                zIndexOffset: 999
                            }).addTo(map);
                            layers.push(arrowMarker);
                        }
                        
                        // One arrow coming back (on last segment)
                        if (coordinates.length > 2) {
                            const lastIdx = coordinates.length - 1;
                            const t = 0.5; // Place arrow in middle of last segment
                            const arrowLat = coordinates[lastIdx - 1][0] + (coordinates[lastIdx][0] - coordinates[lastIdx - 1][0]) * t;
                            const arrowLng = coordinates[lastIdx - 1][1] + (coordinates[lastIdx][1] - coordinates[lastIdx - 1][1]) * t;
                            
                            // Calculate bearing for return direction
                            const returnBearing = calculateBearing(coordinates[lastIdx - 1], coordinates[lastIdx]);
                            
                            const arrowMarker = L.marker([arrowLat, arrowLng], {
                                icon: createArrowMarker([arrowLat, arrowLng], returnBearing, routeColor),
                                interactive: false,
                                zIndexOffset: 999
                            }).addTo(map);
                            layers.push(arrowMarker);
                        }
                    } else {
                        // For one-way routes, show arrows only in forward direction
                        const numArrows = Math.max(2, Math.floor(coordinates.length / 2));
                        for (let i = 1; i <= numArrows; i++) {
                            const t = i / (numArrows + 1);
                            const totalDistance = coordinates.length - 1;
                            const segmentIdx = Math.floor(t * totalDistance);
                            const segmentT = (t * totalDistance) - segmentIdx;
                            
                            if (segmentIdx < totalDistance) {
                                const arrowLat = coordinates[segmentIdx][0] + (coordinates[segmentIdx + 1][0] - coordinates[segmentIdx][0]) * segmentT;
                                const arrowLng = coordinates[segmentIdx][1] + (coordinates[segmentIdx + 1][1] - coordinates[segmentIdx][1]) * segmentT;
                                
                                // Calculate bearing for this specific segment (forward direction)
                                const segmentBearing = calculateBearing(coordinates[segmentIdx], coordinates[segmentIdx + 1]);
                                
                                const arrowMarker = L.marker([arrowLat, arrowLng], {
                                    icon: createArrowMarker([arrowLat, arrowLng], segmentBearing, routeColor),
                                    interactive: false,
                                    zIndexOffset: 999
                                }).addTo(map);
                                layers.push(arrowMarker);
                            }
                        }
                    }

                    // Place one icon at the center of the route with proper bearing
                    const midpoint = getMidpoint(coordinates[0], coordinates[coordinates.length - 1]);
                    const transportIcon = createTransportIcon(route.transport, routeColor, bearing);
                    const iconMarker = L.marker(midpoint, {
                        icon: transportIcon,
                        interactive: false,
                        zIndexOffset: 1000
                    }).addTo(map);

                    layers.push(iconMarker);
                }

                // Add route start/end markers (no day numbers)
                route.path.forEach((cityKey, idx) => {
                    const city = cities[cityKey];
                    if (idx === 0 || idx === route.path.length - 1) {
                        // Use appropriate color based on transport type
                        const markerColor = route.transport === 'plane' ? FLIGHT_COLOR :
                            (route.segments ? FLIGHT_COLOR : ROAD_COLOR);
                        const marker = L.circleMarker([city.lat, city.lng], {
                            radius: 10,
                            fillColor: markerColor,
                            color: '#ffffff',
                            weight: 3,
                            opacity: 1,
                            fillOpacity: 0.9
                        }).addTo(map);

                        layers.push(marker);
                    }
                });
            }

            routeLayers[route.day] = layers;
        });

        // Draw combined bidirectional routes (same path, opposite directions)
        routePairs.forEach(({ route1, route2 }) => {
            const layers = [];
            const coordinates = route1.path.map(cityKey => {
                const city = cities[cityKey];
                return [city.lat, city.lng];
            });

            // Use flight color for bidirectional flight routes
            const routeColor = FLIGHT_COLOR;

            // Calculate bearing for route1 direction (going)
            const bearing1 = calculateBearing(coordinates[0], coordinates[coordinates.length - 1]);
            // Calculate bearing for route2 direction (coming back)
            const bearing2 = calculateBearing(coordinates[coordinates.length - 1], coordinates[0]);

            // Create solid route line
            const routeLine = L.polyline(coordinates, {
                color: routeColor,
                weight: 4,
                opacity: 0.8,
                smoothFactor: 1,
                lineCap: 'round',
                lineJoin: 'round'
            }).addTo(map);

            layers.push(routeLine);

            // Place plane icon going towards destination (first quarter of route)
            const goingPlanePoint = [
                coordinates[0][0] + (coordinates[coordinates.length - 1][0] - coordinates[0][0]) * 0.25,
                coordinates[0][1] + (coordinates[coordinates.length - 1][1] - coordinates[0][1]) * 0.25
            ];
            const planeIconGoing = createTransportIcon('plane', routeColor, bearing1);
            const planeMarkerGoing = L.marker(goingPlanePoint, {
                icon: planeIconGoing,
                interactive: false,
                zIndexOffset: 1000
            }).addTo(map);
            planeMarkerGoing._segmentTransport = 'plane';
            planeMarkerGoing._isSegment = true;
            layers.push(planeMarkerGoing);

            // Place arrow going towards destination (second quarter of route)
            const goingArrowPoint = [
                coordinates[0][0] + (coordinates[coordinates.length - 1][0] - coordinates[0][0]) * 0.35,
                coordinates[0][1] + (coordinates[coordinates.length - 1][1] - coordinates[0][1]) * 0.35
            ];
            const arrowGoing = L.marker(goingArrowPoint, {
                icon: createArrowMarker(goingArrowPoint, bearing1, routeColor),
                interactive: false,
                zIndexOffset: 999
            }).addTo(map);
            layers.push(arrowGoing);

            // Place plane icon coming back (third quarter of route)
            const comingPlanePoint = [
                coordinates[0][0] + (coordinates[coordinates.length - 1][0] - coordinates[0][0]) * 0.65,
                coordinates[0][1] + (coordinates[coordinates.length - 1][1] - coordinates[0][1]) * 0.65
            ];
            const planeIconComing = createTransportIcon('plane', routeColor, bearing2);
            const planeMarkerComing = L.marker(comingPlanePoint, {
                icon: planeIconComing,
                interactive: false,
                zIndexOffset: 1000
            }).addTo(map);
            planeMarkerComing._segmentTransport = 'plane';
            planeMarkerComing._isSegment = true;
            layers.push(planeMarkerComing);

            // Place arrow coming back (last quarter of route)
            const comingArrowPoint = [
                coordinates[0][0] + (coordinates[coordinates.length - 1][0] - coordinates[0][0]) * 0.75,
                coordinates[0][1] + (coordinates[coordinates.length - 1][1] - coordinates[0][1]) * 0.75
            ];
            const arrowComing = L.marker(comingArrowPoint, {
                icon: createArrowMarker(comingArrowPoint, bearing2, routeColor),
                interactive: false,
                zIndexOffset: 999
            }).addTo(map);
            layers.push(arrowComing);

            // Store layers for both routes
            routeLayers[route1.day] = layers;
            routeLayers[route2.day] = layers; // Share the same layers
        });

        // Fit map bounds to show all routes (including Delhi-Vrindavan)
        const allCoordinates = [];
        routes.forEach(route => {
            if (route.path && route.path.length > 1) {
                route.path.forEach(cityKey => {
                    const city = cities[cityKey];
                    if (city) {
                        allCoordinates.push([city.lat, city.lng]);
                    }
                });
            }
        });

        if (allCoordinates.length > 0) {
            // Create a bounds object from all coordinates
            const bounds = L.latLngBounds(allCoordinates);
            // Fit the map to show all routes with some padding
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        // Auto-switch to detailed map when zoomed in for better detail
        map.on('zoomend', function () {
            const currentZoom = map.getZoom();

            // Switch map layers based on zoom
            if (currentZoom >= 9) {
                // When zoomed in close, show detailed street map
                if (map.hasLayer(baseMap)) {
                    map.removeLayer(baseMap);
                }
                if (!map.hasLayer(detailedMap)) {
                    detailedMap.addTo(map);
                }
            } else {
                // When zoomed out, show overview map
                if (map.hasLayer(detailedMap)) {
                    map.removeLayer(detailedMap);
                }
                if (!map.hasLayer(baseMap)) {
                    baseMap.addTo(map);
                }
            }

            // Update visibility of cities and routes based on zoom
            updateVisibilityBasedOnZoom(currentZoom);
        });

        // Initial visibility update
        updateVisibilityBasedOnZoom(map.getZoom());
        }); // End DOMContentLoaded
    </script>
<script src="js/jquery-1.11.3.min.js"></script> 
<script src="js/nav.js"></script>
<script src="js/footer.js"></script>
</body>
</html>